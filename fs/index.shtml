<html lang="en">
  <head>
    <title>Pico GameBoy Printer</title>
  </head>
  <body>

    <center>
      <h1>Pico GameBoy Printer</h1><br>
      Start printing on your GameBoy, then press the "Get Image" button, when the led stops blinking.<br>
      <br>
      <canvas id="canvas" width="160" height="1"></canvas>
      <br><br>
      <button id="get_image_btn">Get image</button>
      <button id="download_image_btn" disabled>Download image...</button>
      <button id="to_gallery_image_btn" disabled>To gallery...</button>
      <br>
      <!--#RESET--> <!--#RAWDATA-->
    </center>
    <center id="gallery"><h2>Gallery:</h2><br></center>

    <script>
      const COMMAND_INIT  = 0x01;
      const COMMAND_PRINT = 0x02;
      const COMMAND_DATA  = 0x04;

      const PRINTER_WIDTH = 20;
      const TILE_SIZE = 0x10;

      const imageBinPath = "/download";

      const canvas = document.getElementById("canvas");
      const getImageBtn = document.getElementById("get_image_btn");
      const downloadImageBtn = document.getElementById("download_image_btn");
      const galleryImageBtn = document.getElementById("to_gallery_image_btn");
      const gallery = document.getElementById("gallery");

      function resize(new_w, new_h) {
        const ctx = canvas.getContext("2d");
        let temp = ctx.getImageData(0, 0, canvas.width, canvas.height)
        canvas.width = new_w;
        canvas.height = new_h;
        ctx.putImageData(temp, 0, 0)
      }

      async function getCameraImage(canvas, binPath) {
        const res = await fetch(imageBinPath);
        const resBody = await res.blob();
        const resBuf = await resBody.arrayBuffer();
        const resData = new Uint8Array(resBuf);
        const data_size = resBody.size;

        processed_data = new Uint8Array(Math.max(1024*1024, data_size));

        canvas.width = canvas.height = 1;

        let buffer_start = 0;
        let ptr = 0;
        let idx = 0;
        let len = 0;
        while (idx < data_size) {
          const command = resData[idx++]; 
          switch(command) {
            case COMMAND_INIT:
//              buffer_start = ptr = 0;
//              canvas.width = canvas.height = 1;
              break;
            case COMMAND_PRINT:
              len = resData[idx] | (resData[idx + 1] << 8);
              idx += 2;
              if (len != 4) {
                idx = data_size;
                break;
              }
              let sheets = resData[idx++];
              let margins = resData[idx++];
              let palette = resData[idx++];
              let exposure = Math.max(0xFF, 0x80 + resData[idx++]);

              palette = (palette) ? palette : 0xE4;

              pal = new Uint8Array(data_size);
              pal[0] = ((exposure * ((palette >> 0) & 0x03)) / 3) >> 0;
              pal[1] = ((exposure * ((palette >> 2) & 0x03)) / 3) >> 0;
              pal[2] = ((exposure * ((palette >> 4) & 0x03)) / 3) >> 0;
              pal[3] = ((exposure * ((palette >> 6) & 0x03)) / 3) >> 0;

              resize((PRINTER_WIDTH * 8), canvas.height + ((Math.max(0, ptr - buffer_start) / (TILE_SIZE * PRINTER_WIDTH)) >> 0) * 8)

              const ctx = canvas.getContext("2d");
              const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              const writeData = imageData.data;
              let tile_y = (((buffer_start / TILE_SIZE) >> 0) / PRINTER_WIDTH) >> 0; 
              let tile_x = ((buffer_start / TILE_SIZE) >> 0) % PRINTER_WIDTH;               
              for (let i = buffer_start; i < ptr; ) {
                for (let t = 0; t < 8; t++) {
                  let b1 = processed_data[i++];
                  let b2 = processed_data[i++];
                  for (let b = 0; b < 8; b++) { 
                    let offset = (((tile_y << 3) + t) * canvas.width + (tile_x << 3) + b) << 2;
                    let color_index = ((b1 >> (7 - b)) & 1) | (((b2 >> (7 - b)) & 1) << 1);

                    writeData[offset + 0] = writeData[offset + 1] = writeData[offset + 2] = 0xFF - pal[color_index];  
                    writeData[offset + 3] = 0xff;
                  }
                }
                tile_x += 1; 
                if (tile_x >= PRINTER_WIDTH) {
                  tile_x = 0; 
                  tile_y++;
                } 
              }
              ctx.putImageData(imageData, 0, 0);

              buffer_start = ptr;
              break;
            case COMMAND_DATA:
              const compression = resData[idx++];
              len = resData[idx] | (resData[idx + 1] << 8);
              idx += 2;
              if (idx + len <= data_size) {
                if (compression) {
                  const stop = idx + len;
                  while (idx < stop) {
                    const tag = resData[idx++];
                    if (tag & 0x80) {
                      const data = resData[idx++];
                      for (let i = 0; i < ((tag & 0x7f) + 2); i++) {
                        processed_data[ptr++] = data;
                      }
                    } else {
                      for (let i = 0; i < (tag + 1); i++) {
                        processed_data[ptr++] = resData[idx++];
                      }
                    }
                  }
                  break;
                } else {
                  for (let i = 0; i < len; i++) {
                    processed_data[ptr++] = resData[idx++];
                  } 
                  break;                  
                }
              } 
              idx = data_size;
              break;
            default:
              idx = data_size;
              break;
          }
        }

        downloadImageBtn.disabled = galleryImageBtn.disabled = (canvas.height == 1);
      }

      async function downloadCanvasAsImage(canvas) {
        const canvasImage = canvas.toDataURL("image/png");
        if (window.showSaveFilePicker) {
          // Use file picker
          const fileHandle = await window.showSaveFilePicker({
            suggestedName: "image.png",
          });
          const writable = await fileHandle.createWritable();
          canvas.toBlob(async (blob) => {
            await writable.write(blob);
            await writable.close();
          });
        } else {
          // Fallback to simple download
          const xhr = new XMLHttpRequest();
          xhr.responseType = "blob";
          xhr.onload = function () {
            const a = document.createElement("a");
            a.href = window.URL.createObjectURL(xhr.response);
            a.download = "image.png";
            a.style.display = "none";
            document.body.appendChild(a);
            a.click();
            a.remove();
          };
          xhr.open("GET", canvasImage);
          xhr.send();
        }
      }

      getImageBtn.addEventListener("click", async function () {
        await getCameraImage(canvas, imageBinPath);
        if (canvas.height > 1) {
          downloadImageBtn.disabled = false;
          galleryImageBtn.disabled = false;
        }
      });

      downloadImageBtn.addEventListener("click", function () {
        downloadCanvasAsImage(canvas);
      });

      galleryImageBtn.addEventListener("click", function () {
        if (canvas.height > 1) {
          var img = new Image();
          img.src = canvas.toDataURL();
          gallery.appendChild(img);
        }
      });
    </script>
  </body>
</html>
