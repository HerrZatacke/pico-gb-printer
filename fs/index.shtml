<html lang="en">
  <head>
    <title>Pico GameBoy Printer</title>
  </head>
  <body>

    <center>
      <h1>Pico GameBoy Printer</h1><br>
      Start printing on your GameBoy, then press the "Get Image" button, when the led stops blinking.<br>
      <br>
      <canvas id="canvas" width="160" height="1"></canvas>
      <br><br>
      <button id="get_image_btn">Get image</button>
      <input type="text" id="download_file_name" style="width:70">
      <button id="download_image_btn" disabled>Download image...</button>
      <button id="tear_btn">Tear</button>
      <br>
      <!--#RESET--> <!--#RAWDATA-->
      <h2>Gallery:</h2>
      <button id="to_gallery_btn" disabled>Add to gallery...</button>
      <button id="delete_selected_btn" disabled>Delete selected...</button>
      <br>
      <br>
    </center>
    <div id="gallery" style="display: flex;flex-wrap: wrap;justify-content: center;align-items: flex-start;"></div>

    <script>
      const COMMAND_INIT  = 0x01;
      const COMMAND_PRINT = 0x02;
      const COMMAND_DATA  = 0x04;

      const PRINTER_WIDTH = 20;
      const TILE_SIZE = 0x10;

      const imageBinPath = "/download";
      const resetPath = "/reset";

      let downloadIndex = 0;

      const canvas = document.getElementById("canvas");
      const getImageBtn = document.getElementById("get_image_btn");
      const downloadImageBtn = document.getElementById("download_image_btn");
      const downloadFileName = document.getElementById("download_file_name");
      const togalleryBtn = document.getElementById("to_gallery_btn");
      const gallery = document.getElementById("gallery");
      const tearBtn = document.getElementById("tear_btn");
      const deleteSelectedBtn = document.getElementById("delete_selected_btn");

      String.prototype.format = function() {
        var formatted = this;
        for (var i = 0; i < arguments.length; i++) {
          var regexp = new RegExp('\\{'+i+'\\}', 'gi');
          formatted = formatted.replace(regexp, arguments[i]);
        }
        return formatted;
      };

      function resize(new_w, new_h) {
        const ctx = canvas.getContext("2d");
        let temp = ctx.getImageData(0, 0, canvas.width, canvas.height)
        canvas.width = new_w;
        canvas.height = new_h;
        ctx.putImageData(temp, 0, 0)
      }

      async function getCameraImage(canvas, binPath) {
        const res = await fetch(imageBinPath);
        const resBody = await res.blob();
        const resBuf = await resBody.arrayBuffer();
        const resData = new Uint8Array(resBuf);
        const data_size = resBody.size;

        processed_data = new Uint8Array(Math.max(1024*1024, data_size));

        canvas.width = canvas.height = 1;

        let buffer_start = 0;
        let ptr = 0;
        let idx = 0;
        let len = 0;
        while (idx < data_size) {
          const command = resData[idx++]; 
          switch(command) {
            case COMMAND_INIT:
              break;
            case COMMAND_PRINT:
              len = resData[idx] | (resData[idx + 1] << 8);
              idx += 2;
              if (len != 4) {
                idx = data_size;
                break;
              }
              let sheets = resData[idx++];
              let margins = resData[idx++];
              let palette = resData[idx++];
              let exposure = Math.max(0xFF, 0x80 + resData[idx++]);

              palette = (palette) ? palette : 0xE4;

              pal = new Uint8Array(data_size);
              pal[0] = ((exposure * ((palette >> 0) & 0x03)) / 3) >> 0;
              pal[1] = ((exposure * ((palette >> 2) & 0x03)) / 3) >> 0;
              pal[2] = ((exposure * ((palette >> 4) & 0x03)) / 3) >> 0;
              pal[3] = ((exposure * ((palette >> 6) & 0x03)) / 3) >> 0;

              resize((PRINTER_WIDTH * 8), canvas.height + ((Math.max(0, ptr - buffer_start) / (TILE_SIZE * PRINTER_WIDTH)) >> 0) * 8)

              const ctx = canvas.getContext("2d");
              const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              const writeData = imageData.data;
              let tile_y = (((buffer_start / TILE_SIZE) >> 0) / PRINTER_WIDTH) >> 0; 
              let tile_x = ((buffer_start / TILE_SIZE) >> 0) % PRINTER_WIDTH;               
              for (let i = buffer_start; i < ptr; ) {
                for (let t = 0; t < 8; t++) {
                  let b1 = processed_data[i++];
                  let b2 = processed_data[i++];
                  for (let b = 0; b < 8; b++) { 
                    let offset = (((tile_y << 3) + t) * canvas.width + (tile_x << 3) + b) << 2;
                    let color_index = ((b1 >> (7 - b)) & 1) | (((b2 >> (7 - b)) & 1) << 1);

                    writeData[offset + 0] = writeData[offset + 1] = writeData[offset + 2] = 0xFF - pal[color_index];  
                    writeData[offset + 3] = 0xff;
                  }
                }
                tile_x += 1; 
                if (tile_x >= PRINTER_WIDTH) {
                  tile_x = 0; 
                  tile_y++;
                } 
              }
              ctx.putImageData(imageData, 0, 0);

              buffer_start = ptr;
              break;
            case COMMAND_DATA:
              const compression = resData[idx++];
              len = resData[idx] | (resData[idx + 1] << 8);
              idx += 2;
              if (idx + len <= data_size) {
                if (compression) {
                  const stop = idx + len;
                  while (idx < stop) {
                    const tag = resData[idx++];
                    if (tag & 0x80) {
                      const data = resData[idx++];
                      for (let i = 0; i < ((tag & 0x7f) + 2); i++) {
                        processed_data[ptr++] = data;
                      }
                    } else {
                      for (let i = 0; i < (tag + 1); i++) {
                        processed_data[ptr++] = resData[idx++];
                      }
                    }
                  }
                  break;
                } else {
                  for (let i = 0; i < len; i++) {
                    processed_data[ptr++] = resData[idx++];
                  } 
                  break;                  
                }
              } 
              idx = data_size;
              break;
            default:
              idx = data_size;
              break;
          }
        }

        downloadImageBtn.disabled = togalleryBtn.disabled = (canvas.height == 1);
      }

      async function downloadCanvasAsImage(canvas) {
        const canvasImage = canvas.toDataURL("image/png");
        let file_name = downloadFileName.value;
        if (file_name.length == 0) {
          downloadIndex += 1;
          file_name = "image{0}.png".format(downloadIndex);
        }
        if (window.showSaveFilePicker) {
          // Use file picker
          const fileHandle = await window.showSaveFilePicker({
            suggestedName: file_name,
          });
          const writable = await fileHandle.createWritable();
          canvas.toBlob(async (blob) => {
            await writable.write(blob);
            await writable.close();
          });
        } else {
          // Fallback to simple download
          const xhr = new XMLHttpRequest();
          xhr.responseType = "blob";
          xhr.onload = function () {
            const a = document.createElement("a");
            a.href = window.URL.createObjectURL(xhr.response);
            a.download = file_name;
            a.style.display = "none";
            document.body.appendChild(a);
            a.click();
            a.remove();
          };
          xhr.open("GET", canvasImage);
          xhr.send();
        }
      }

      getImageBtn.addEventListener("click", async function () {
        await getCameraImage(canvas, imageBinPath);
        if (canvas.height > 1) {
          downloadImageBtn.disabled = false;
          togalleryBtn.disabled = false;
        }
      });

      downloadImageBtn.addEventListener("click", function () {
        downloadCanvasAsImage(canvas);
      });

      togalleryBtn.addEventListener("click", function () {
        if (canvas.height > 1) {
          const div = document.createElement("DIV");
          const img = new Image();
          img.src = canvas.toDataURL();
          div.appendChild(img);
          div.markedForDeletion = false;          
          const input = document.createElement("INPUT");
          input.setAttribute("type", "checkbox");
          input.addEventListener("change", function() {
            deleteSelectedBtn.disabled = !(div.markedForDeletion = (input.checked));
            if  (!deleteSelectedBtn.disabled) return;
            var items = gallery.children;
            for (var i = 0; i < items.length; i++) {
              if (!(deleteSelectedBtn.disabled = !(items[i].markedForDeletion))) break; 
            }
          });
          div.appendChild(input);
          gallery.appendChild(div);
        }
      });

      deleteSelectedBtn.addEventListener("click", function () {
        var items = gallery.children;
        for (var i = items.length - 1; i >= 0; i--) {
          if (items[i].markedForDeletion) items[i].remove();
        }
        deleteSelectedBtn.disabled = true;
      });

      tearBtn.addEventListener("click", async function () {
        fetch(resetPath)
          .then((response) => {
            return response.json();
          })
          .then((data) => {
            if (data.result != "ok") return;
            getImageBtn.click();
          });
      });

    </script>
  </body>
</html>
