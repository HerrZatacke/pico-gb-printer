<html lang="en">
  <head>
    <title>Pico GameBoy Printer</title>
  </head>
  <body>

    <center>
      <h1>Pico GameBoy Printer</h1><br>
      Start printing on your GameBoy, then press the "Get Image" button, when the led stops blinking.<br>
      <br>
      <canvas id="canvas" width="160" height="1"></canvas>
      <br><br>
      <button id="get_image_btn">Get image</button>
      <input type="text" id="download_file_name" style="width:70">
      <button id="download_image_btn" disabled>Download image...</button>
      <button id="tear_btn">Tear</button>
      <br>
      <!--#RESET--> <!--#RAWDATA-->
      <h2>Gallery:</h2>
      <button id="to_gallery_btn" disabled>Add to gallery...</button>
      <button id="delete_selected_btn" disabled>Delete selected...</button>
      <br>
      <br>
    </center>
    <div id="gallery" style="display: flex;flex-wrap: wrap;justify-content: center;align-items: flex-start;"></div>

    <script>
      const COMMAND_INIT      = 0x01;
      const COMMAND_PRINT     = 0x02;
      const COMMAND_DATA      = 0x04;
      const COMMAND_TRANSFER  = 0x10;

      const PRINTER_WIDTH = 20;
      const CAMERA_WIDTH  = 16;
      const TILE_SIZE     = 0x10;

      const imageBinPath  = "/download";
      const resetPath     = "/reset";

      let downloadIndex = 0;

      const canvas = document.getElementById("canvas");
      const getImageBtn = document.getElementById("get_image_btn");
      const downloadImageBtn = document.getElementById("download_image_btn");
      const downloadFileName = document.getElementById("download_file_name");
      const togalleryBtn = document.getElementById("to_gallery_btn");
      const gallery = document.getElementById("gallery");
      const tearBtn = document.getElementById("tear_btn");
      const deleteSelectedBtn = document.getElementById("delete_selected_btn");

      String.prototype.format = function() {
        var formatted = this;
        for (var i = 0; i < arguments.length; i++) {
          var regexp = new RegExp('\\{'+i+'\\}', 'gi');
          formatted = formatted.replace(regexp, arguments[i]);
        }
        return formatted;
      };

      function resize(new_w, new_h) {
        const ctx = canvas.getContext("2d");
        let temp = ctx.getImageData(0, 0, canvas.width, canvas.height)
        canvas.width = new_w;
        canvas.height = new_h;
        ctx.putImageData(temp, 0, 0)
      }

      function render(image_data, image_start, image_end, image_tile_width, sheets, margin, palette, exposure) {
        pal = new Uint8Array(4);
        pal[0] = ((exposure * ((palette >> 0) & 0x03)) / 3) >> 0;
        pal[1] = ((exposure * ((palette >> 2) & 0x03)) / 3) >> 0;
        pal[2] = ((exposure * ((palette >> 4) & 0x03)) / 3) >> 0;
        pal[3] = ((exposure * ((palette >> 6) & 0x03)) / 3) >> 0;

        resize((image_tile_width * 8), canvas.height + ((Math.max(0, image_end - image_start) / (TILE_SIZE * image_tile_width)) >> 0) * 8)

        const ctx = canvas.getContext("2d");
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const writeData = imageData.data;
        let tile_y = (((image_start / TILE_SIZE) >> 0) / image_tile_width) >> 0;
        let tile_x = ((image_start / TILE_SIZE) >> 0) % image_tile_width;
        for (let i = image_start; i < image_end; ) {
          for (let t = 0; t < 8; t++) {
            let b1 = image_data[i++];
            let b2 = image_data[i++];
            for (let b = 0; b < 8; b++) {
              let offset = (((tile_y << 3) + t) * canvas.width + (tile_x << 3) + b) << 2;
              let color_index = ((b1 >> (7 - b)) & 1) | (((b2 >> (7 - b)) & 1) << 1);

              writeData[offset + 0] = writeData[offset + 1] = writeData[offset + 2] = 0xFF - pal[color_index];
              writeData[offset + 3] = 0xff;
            }
          }
          tile_x += 1;
          if (tile_x >= image_tile_width) {
            tile_x = 0;
            tile_y++;
          }
        }
        ctx.putImageData(imageData, 0, 0);

        return (margin == 0x03);
      }

      function decode(is_compressed, sour, sour_size, sour_data_len, sour_ptr, dest, dest_ptr) {
        if (sour_ptr + sour_data_len <= sour_size) {
          if (is_compressed) {
            const stop = sour_ptr + sour_data_len;
            while (sour_ptr < stop) {
              const tag = sour[sour_ptr++];
              if (tag & 0x80) {
                const data = sour[sour_ptr++];
                for (let i = 0; i < ((tag & 0x7f) + 2); i++) {
                  dest[dest_ptr++] = data;
                }
              } else {
                for (let i = 0; i < (tag + 1); i++) {
                  dest[dest_ptr++] = sour[sour_ptr++];
                }
              }
            }
            return dest_ptr;
          } else {
            for (let i = 0; i < sour_data_len; i++) {
              dest[dest_ptr++] = sour[sour_ptr++];
            }
            return dest_ptr;
          }
        }
        return dest_ptr;
      }

      async function getCameraImage(canvas, binPath) {
        const res = await fetch(imageBinPath);
        const resBody = await res.blob();
        const resBuf = await resBody.arrayBuffer();
        const resData = new Uint8Array(resBuf);
        const data_size = resBody.size;

        processed_data = new Uint8Array(Math.max(1024*1024, data_size));

        canvas.width = canvas.height = 1;

        let buffer_start = 0;
        let ptr = 0;
        let idx = 0;
        let len = 0;
        while (idx < data_size) {
          const command = resData[idx++];
          switch(command) {
            case COMMAND_INIT:
              break;
            case COMMAND_PRINT:
              if ((len = resData[idx++] | (resData[idx++] << 8)) != 4) {
                idx = data_size;
                break;
              }
              let sheets = resData[idx++];
              let margins = resData[idx++];
              let palette = resData[idx++];
              let exposure = Math.min(0xFF, 0x80 + resData[idx++]);

              palette = (palette) ? palette : 0xE4;

              render(processed_data, buffer_start, ptr, PRINTER_WIDTH, sheets, margins, palette, exposure);

              buffer_start = ptr;
              break;
            case COMMAND_TRANSFER: {
              len = resData[idx++] | (resData[idx++] << 8);
              let current_image_start = ptr;
              ptr = decode(false, resData, data_size, len, idx, processed_data, ptr);
              idx += len;
              render(processed_data, current_image_start, ptr, CAMERA_WIDTH, 1, 0x03, 0xE4, 0xFF);
              break;
            }
            case COMMAND_DATA: {
              const compression = resData[idx++];
              len = resData[idx++] | (resData[idx++] << 8);
              ptr = decode(compression, resData, data_size, len, idx, processed_data, ptr);
              idx += len;
              break;
            }
            default:
              idx = data_size;
              break;
          }
        }

        downloadImageBtn.disabled = togalleryBtn.disabled = (canvas.height == 1);
      }

      async function downloadCanvasAsImage(canvas) {
        const canvasImage = canvas.toDataURL("image/png");
        let file_name = downloadFileName.value;
        if (file_name.length == 0) {
          downloadIndex += 1;
          file_name = "image{0}.png".format(downloadIndex);
        }
        if (window.showSaveFilePicker) {
          // Use file picker
          const fileHandle = await window.showSaveFilePicker({
            suggestedName: file_name,
          });
          const writable = await fileHandle.createWritable();
          canvas.toBlob(async (blob) => {
            await writable.write(blob);
            await writable.close();
          });
        } else {
          // Fallback to simple download
          const xhr = new XMLHttpRequest();
          xhr.responseType = "blob";
          xhr.onload = function () {
            const a = document.createElement("a");
            a.href = window.URL.createObjectURL(xhr.response);
            a.download = file_name;
            a.style.display = "none";
            document.body.appendChild(a);
            a.click();
            a.remove();
          };
          xhr.open("GET", canvasImage);
          xhr.send();
        }
      }

      getImageBtn.addEventListener("click", async function () {
        await getCameraImage(canvas, imageBinPath);
        if (canvas.height > 1) {
          downloadImageBtn.disabled = false;
          togalleryBtn.disabled = false;
        }
      });

      downloadImageBtn.addEventListener("click", function () {
        downloadCanvasAsImage(canvas);
      });

      togalleryBtn.addEventListener("click", function () {
        if (canvas.height > 1) {
          const div = document.createElement("DIV");
          const img = new Image();
          img.src = canvas.toDataURL();
          div.appendChild(img);
          div.markedForDeletion = false;
          const input = document.createElement("INPUT");
          input.setAttribute("type", "checkbox");
          input.addEventListener("change", function() {
            deleteSelectedBtn.disabled = !(div.markedForDeletion = (input.checked));
            if  (!deleteSelectedBtn.disabled) return;
            var items = gallery.children;
            for (var i = 0; i < items.length; i++) {
              if (!(deleteSelectedBtn.disabled = !(items[i].markedForDeletion))) break;
            }
          });
          div.appendChild(input);
          gallery.appendChild(div);
        }
      });

      deleteSelectedBtn.addEventListener("click", function () {
        var items = gallery.children;
        for (var i = items.length - 1; i >= 0; i--) {
          if (items[i].markedForDeletion) items[i].remove();
        }
        deleteSelectedBtn.disabled = true;
      });

      tearBtn.addEventListener("click", async function () {
        fetch(resetPath)
          .then((response) => {
            return response.json();
          })
          .then((data) => {
            if (data.result != "ok") return;
            getImageBtn.click();
          });
      });

    </script>
  </body>
</html>
